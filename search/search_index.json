{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>This website hosts the official documentation for the FirecrackerSharp SDK.</p> <p>FirecrackerSharp is a C# SDK for the innovative Firecracker microVM hypervisor developed by Amazon. It allows developers to:</p> <ul> <li>Boot up and shutdown microVMs</li> <li>Use different virtual machine hosts, bypassing the need for a Linux developer machine</li> <li>Use microVM jailing in order to tighten security without much extra effort</li> <li>Manage the microVM's lifecycle with fine-grained logging capabilities and error handling</li> <li>Connect to the microVM's HTTP server over a Unix domain socket for managing it, with (mostly) complete bindings to the OpenAPI specification and robust static typing and error handling</li> <li>Automate installing, updating and tracking installations of Firecracker via GitHub's API</li> <li>Interact with a microVM through its serial console in a thread-safe manner with:<ul> <li>Advanced output buffering, allowing piping out output to different sources and not necessarily into RAM</li> <li>State management via completion tracking, allowing for complete thread-safety and reliable primary and intermittent writes</li> </ul> </li> <li>Split up a microVM's serial console into multiple terminals via TTY multiplexing (will be available in 1.0)</li> <li>Automatically spin up host and guest network interfaces via CNI plugins (will be available in 1.0)</li> </ul> <p>To learn what Firecracker is and what capabilities it offers for applications that need virtualization, check out its official website: https://firecracker-microvm.github.io/.</p> <p>To get started with using this (unofficial) .NET SDK for Firecracker, check out the tutorial in order to set up your development environment for Firecracker and .NET.</p>"},{"location":"#why-firecracker","title":"Why Firecracker","text":"<p>While QEMU, for example, supports (comparative to Firecracker) few VMs with full feature set, Firecracker is a alternative also using KVM internally that focuses on incredibly high amounts of atomic, lightweight and security-proofed VMs for so-called \"edge workloads\". This is why Firecracker is being used in AWS for the AWS Lambda service, providing real and secure host-to-guest isolation (unlike containers) without the overhead of QEMU, VMWare, VirtualBox or Hyper-V virtual machines.</p>"},{"location":"#stability-of-this-sdk","title":"Stability of this SDK","text":"<p>FirecrackerSharp is already quite stable and offers a variety of thoroughly unit- and integration-tested features, however there are still some things that need to be ironed out and thus it's still in beta. Breaking changes happen regularly, so using it in production is not yet recommended.</p>"},{"location":"getting-started/1-environment-setup/","title":"Environment setup","text":""},{"location":"getting-started/1-environment-setup/#about-firecrackersharps-hosts","title":"About FirecrackerSharp's hosts","text":"<p>Firecracker is a highly performant hypervisor, however it is Linux-only and relies on KVM, a Linux kernel-exclusive module for virtualization.</p> <p>FirecrackerSharp, unlike any other Firecracker SDK, allows you to use virtual hosts other than a Linux desktop/server. This is implemented via a VM host abstraction that has several implementations:</p> <ul> <li>The local host (<code>FirecrackerSharp.Host.Local</code> on NuGet), this uses a Linux desktop/server without any layers of indirection. Prefer to use this in production in all possible cases, as it's (understandably) the most resilient virtual host there is.</li> <li>The SSH host (<code>FirecrackerSharp.Host.Ssh</code> on NuGet), this connects to a remote Linux server over SSH (using SSH.NET), uses its filesystem over SFTP and runs commands (or virtual terminals) over SSH.</li> </ul> <p>In the future, more hosts are planned (such as a Docker/Podman rootful container host).</p> <p>Using these hosts, here are the most common ways to configure your environment:</p>"},{"location":"getting-started/1-environment-setup/#1-a-linux-desktop-with-hardware-virtualization","title":"1. A Linux desktop with hardware virtualization","text":"<p>This is the setup the developers of FirecrackerSharp use, and it's the one we highly recommend if using Linux for .NET development isn't a severe issue (considering that all of .NET is cross-platform and there are better IDE options than Visual Studio, using Linux would not be a problem).</p> <p>When possible, try to adhere to Firecracker's supported host and guest kernels. While it's absolutely possible to run it on, for example, the 6.9 host Linux kernel instead of the latest supported 6.1, it may cause some issues the SDK can't deal with.</p> <ol> <li>Enable virtualization in your BIOS, refer to the instructions of your BIOS's manufacturer and the type of your CPU to see which option to use, then reboot.</li> <li>Install KVM to your Linux distribution. The easiest route would be to install QEMU alongside it. Follow your distribution's documentation on how to install QEMU, then reboot.</li> <li>Verify you've installed KVM by running: <code>lsmod | grep kvm</code>. The output should contain something like <code>kvm_amd</code> or <code>kvm_intel</code> or just <code>kvm</code> for you to be sure that KVM is enabled.</li> <li>Gain access to KVM as your rootless user (running the jailer will still require the root password, however the SDK supports escalation of privileges).<ul> <li>For access managed through an access control list: <code>sudo setfacl -m u:${USER}:rw /dev/kvm</code></li> <li>For access managed through a kvm group: <code>[ $(stat -c \"%G\" /dev/kvm) = kvm ] &amp;&amp; sudo usermod -aG kvm ${USER} &amp;&amp; echo \"Access granted.\"</code></li> </ul> </li> <li>Verify you have KVM access via <code>[ -r /dev/kvm ] &amp;&amp; [ -w /dev/kvm ] &amp;&amp; echo \"OK\" || echo \"FAIL\"</code>.</li> </ol> <p>Now you should be good to go! Firecracker doesn't depend on any particular Linux distribution, but it's most often used in either Debian and Ubuntu for the 6.1 host kernel.</p>"},{"location":"getting-started/1-environment-setup/#2-a-linux-vm","title":"2. A Linux VM","text":"<p>Here, you will need to create a virtual machine running Linux (preferably Debian, since it uses the 6.1 kernel).</p> <p>On Windows, use Hyper-V, VMWare or VirtualBox. On Linux, simply install QEMU and virt-manager to create the virtual machine.</p> <p>On a Linux host, ensure the VM is on a bridge network interface. Then, run <code>ip addr</code> to get its address on your local network and install SSH. For different distributions, the process will vary, for Debian use the following instructions:</p> <ol> <li><code>sudo apt-get install -y openssh-server</code></li> <li>Edit <code>/etc/ssh/sshd_config</code> and set <code>PermitRootLogin yes</code> so you that you can log into the root account with the root password</li> <li><code>sudo systemctl enable ssh</code></li> <li><code>sudo systemctl restart ssh</code></li> <li>Go into your router's DHCP configuration and give the VM's local IP a static lease</li> </ol> <p>On a Windows host, follow the instructions on how to assign a static local IP to your VM, then analogously install SSH inside the VM.</p> <p>After installing the VM, enable nested virtualization for the VM so that it has KVM access. This will depend on which hypervisor you're using. Then, run <code>lsmod | grep kvm</code> to ensure KVM is accessible inside the VM.</p>"},{"location":"getting-started/1-environment-setup/#3-a-linux-bare-metal-server","title":"3. A Linux bare metal server","text":"<p>If it's your own hardware:</p> <ol> <li>Find the server's IP via <code>ip addr</code></li> <li>Give it a static DHCP lease through the router</li> <li>Install an SSH server like shown in section 2</li> <li>Enable virtualization, install KVM like in preceding sections</li> </ol> <p>If you're using a cloud provider, refer to Firecracker's development team's recommendations. It'll cost a fair amount to get a bare metal server in the cloud, but it's generally worth it if you can.</p>"},{"location":"getting-started/1-environment-setup/#4-wsl2-with-nested-virtualization-and-ssh","title":"4. WSL2 with nested virtualization and SSH","text":"<p>Warning: WSL is a pretty specific type of Linux VM and you may encounter issues using it for nested virtualization you wouldn't have with a conventional VM made in Hyper-V, VirtualBox or VMWare. If possible, opt for a traditional VM instead when running Windows. The WSL + SSH approach hasn't been thoroughly tested and we don't provide official support for it.</p> <p>Follow the instructions on how to set up WSL2, enable KVM nested virtualization, and then install SSH in it. More detailed instructions will be added later.</p>"},{"location":"getting-started/2-installing-the-sdk/","title":"Installing the SDK","text":""},{"location":"getting-started/2-installing-the-sdk/#installing-packages","title":"Installing packages","text":"<p>To use FirecrackerSharp, you'll need the core package (<code>FirecrackerSharp</code>):</p> <p><code>dotnet add package FirecrackerSharp</code></p> <p>And then, one of the hosts, the local host is installed as follows:</p> <p><code>dotnet add package FirecrackerSharp.Host.Local</code></p> <p>And the SSH host is installed as follows:</p> <p><code>dotnet add package FirecrackerSharp.Host.Ssh</code></p>"},{"location":"getting-started/2-installing-the-sdk/#configuring-the-host","title":"Configuring the host","text":"<p>For now, the hosts are configured via static classes (<code>LocalHost</code> or <code>SshHost</code>). An ASP.NET Core-specific extension that will use Microsoft's DI to do it is planned for the 1.0 release, but not available yet.</p>"},{"location":"getting-started/2-installing-the-sdk/#local-host","title":"Local host","text":"<p>Simply call:</p> <pre><code>LocalHost.Configure();\n</code></pre> <p>No extra configuration is needed, everything should \"just work\".</p>"},{"location":"getting-started/2-installing-the-sdk/#ssh-host","title":"SSH host","text":"<p>The SSH host needs three main configurations to work, the first is a connection pool configuration that will specify the settings of the SSH and SFTP connection pool and the credentials used to connect to the destination:</p> <pre><code>public sealed record ConnectionPoolConfiguration(\n    ConnectionInfo ConnectionInfo,\n    uint SshConnectionAmount,\n    uint SftpConnectionAmount,\n    TimeSpan KeepAliveInterval);\n</code></pre> <p>The second configuration is used to create PTYs (virtual terminals) that are needed to launch and interact with the firecracker/jailer processes. There's a sensible default configuration at <code>ShellConfiguration.Default</code>:</p> <pre><code>public sealed record ShellConfiguration(\n    string Terminal,\n    uint Columns,\n    uint Rows,\n    uint Width,\n    uint Height,\n    int BufferSize)\n{\n    public static readonly ShellConfiguration Default = new(\n        \"/bin/bash\", 1000, 1000, 1000, 1000, 1000);\n}\n</code></pre> <p>The third configuration is used for the <code>curl</code> tool that is needed to make HTTP requests to Unix domain sockets of the Firecracker process. SSH.NET needs to support Unix socket forwarding for this not to be necessary, but the related issue hasn't been resolved for more than 7 years, so <code>curl</code> is used over SSH instead. A sensible default configuration is available at <code>CurlConfiguration.Default</code>:</p> <pre><code>public sealed record CurlConfiguration(\n    TimeSpan PollFrequency,\n    int RetryAmount,\n    int RetryDelaySeconds,\n    int RetryMaxTimeSeconds)\n{\n    public static readonly CurlConfiguration Default = new(TimeSpan.FromMilliseconds(5), 1, 0, 20);\n}\n</code></pre> <p>Lastly, ensure the following packages are installed on the SSH Linux machine!:</p> <ul> <li><code>tar</code> (working with archives)</li> <li><code>untar</code> or <code>unar</code> (same thing)</li> <li><code>curl</code> (requests)</li> </ul> <p>To set up the host, call <code>SshHost</code> like so:</p> <pre><code>SshHost.Configure(new ConnectionPoolConfiguration(...), new CurlConfiguration(...), new ShellConfiguration(...));\n</code></pre> <p>The connection pool keeps up the constant amount of SSH and SFTP connections through your app's lifetime. Ensure the connection pool is disposed of like so:</p> <pre><code>SshHost.Dispose();\n</code></pre>"},{"location":"getting-started/3-creating-a-basic-app/","title":"Creating a basic app","text":"<p>In this tutorial, we'll create a sample app that:</p> <ul> <li>Boots up an unrestricted VM (lifecycle)</li> <li>Pauses and resumes the VM (management)</li> <li>Runs a basic buffered command via the VM's TTY (classic TTY)</li> <li>Shuts down the unrestricted VM (lifecycle)</li> </ul> <p>This is a basic quickstart for working with the most common features of this SDK. To learn more about each of these topics (which you should, in order to use the SDK's full capabilities), refer to other sections in the documentation.</p> <p>The sample's source code is available in the sample GitHub repository.</p>"},{"location":"getting-started/3-creating-a-basic-app/#getting-started","title":"Getting started","text":"<p>First, create a new CLI project, install the core SDK package and the host you'll be using according to the installation instructions. We'll be using the local host here as well as in all other samples.</p> <p>Create the sample class:</p> <pre><code>namespace CreatingABasicApp;\n\npublic static class BasicAppSample\n{\n    public static async Task RunAsync()\n    {\n    }\n}\n</code></pre> <p>Invoke it from <code>Program.cs</code>:</p> <pre><code>using CreatingABasicApp;\n\nawait BasicAppSample.RunAsync();\n</code></pre> <p>And start by configuring your host in <code>RunAsync</code>:</p> <pre><code>// Start by setting up the virtual host. Here, a local host is used, replace with another host if necessary\nLocalHost.Configure();\n</code></pre>"},{"location":"getting-started/3-creating-a-basic-app/#download-all-necessary-resources","title":"Download all necessary resources","text":"<p>To boot a microVM, several resources are required:</p> <ul> <li>An uncompressed Linux kernel, preferably either 5.10 or 6.1</li> <li>A rootfs, also known as the root filesystem, this contains your distribution, init system, installed packages, and is the entirety of <code>/</code> on your VM that will be used as a tmpfs</li> <li>(Optionally) An initrd (initial RAM disk), which we won't use in this case</li> </ul> <p>Usually, you'd build a rootfs yourself (sometimes also the Linux kernel), but for these purposes we're going to use the one Firecracker's devs use in their CI, which has Ubuntu 22.04 with systemd inside. And we'll also download the prebuilt kernel:</p> <pre><code>ARCH=\"$(uname -m)\"\n\n# Download a linux kernel binary\nwget https://s3.amazonaws.com/spec.ccfc.min/firecracker-ci/v1.9/${ARCH}/vmlinux-5.10.217\n\n# Download a rootfs\nwget https://s3.amazonaws.com/spec.ccfc.min/firecracker-ci/v1.9/${ARCH}/ubuntu-22.04.ext4\n</code></pre> <p>For the sake of simplicity, create <code>/opt/res</code> with sudo and save the kernel to <code>/opt/res/kernel</code> and the rootfs to <code>/opt/res/rootfs.ext4</code>.</p> <p>Now, we'll need the Firecracker hypervisor itself: go to the release page, download the latest release, extract the archive and rename the binary starting with <code>firecracker</code> to just <code>firecracker</code> and place it under <code>/opt/res</code>. Do the same for the binary starting with <code>jailer</code>. Later, you'll learn how this process can be automated with the SDK.</p> <p>Ensure the <code>firecracker</code> and <code>jailer</code> binaries are executable with <code>chmod +x</code>!</p>"},{"location":"getting-started/3-creating-a-basic-app/#configure-the-vm","title":"Configure the VM","text":"<p>The first element of the VM is a <code>VmConfiguration</code>, this contains the properties of the future VM and will be passed down to Firecracker (in different possible ways, which we won't cover here).</p> <p>Create your <code>VmConfiguration</code> in <code>RunAsync</code>:</p> <pre><code>// Configure the future VM\nvar vmConfiguration = new VmConfiguration(\n    // boot data: kernel, args, initrd\n    BootSource: new VmBootSource(\n        KernelImagePath: \"/opt/res/kernel\",\n        BootArgs: \"console=ttyS0 reboot=k panic=1 pci=off\",\n        InitrdPath: null /* we aren't using an initrd */),\n    // hardware configuration\n    new VmMachineConfiguration(\n        MemSizeMib: 128 /* 128 MB of ram */,\n        VcpuCount: 1 /* 1 vCPU */),\n    // drives, here: only the rootfs\n    Drives: [\n        new VmDrive(\n            DriveId: \"rootfs\",\n            IsRootDevice: true,\n            PathOnHost: \"/opt/res/rootfs.ext4\")\n    ]\n);\n</code></pre> <p>The second element is a link to the Firecracker installation:</p> <pre><code>var firecrackerInstall = new FirecrackerInstall(\n    Version: \"v1.7.0\", // replace with the one you're using\n    FirecrackerBinary: \"/opt/res/firecracker\",\n    JailerBinary: \"/opt/res/jailer\");\n</code></pre> <p>The third element are the arguments that need to be passed to the Firecracker binary:</p> <pre><code>var firecrackerOptions = new FirecrackerOptions(\n    SocketFilename: $\"{Guid.NewGuid()}\",\n    SocketDirectory: \"/tmp\");\n</code></pre> <p>Lastly, we'll need the VM ID, which should be unique for every VM. Let's generate it randomly:</p> <pre><code>var vmId = Random.Shared.Next(1, 10000).ToString();\n</code></pre>"},{"location":"getting-started/3-creating-a-basic-app/#booting-up-the-vm","title":"Booting up the VM","text":"<p>First, we'll create an instance of the VM. Since we aren't using jailing, we're using <code>UnrestrictedVm</code>. Then we boot it up. In the period between these actions, we can perform configuration of lifecycle logging, but this is out of scope of this guide:</p> <pre><code>// Create the VM instance and boot it\nvar vm = new UnrestrictedVm(vmConfiguration, firecrackerInstall, firecrackerOptions, vmId);\nvar bootResult = await vm.BootAsync();\nif (bootResult.IsFailure())\n{\n    Console.WriteLine(\"Couldn't boot VM!\");\n    return;\n}\n</code></pre>"},{"location":"getting-started/3-creating-a-basic-app/#managing-the-vm","title":"Managing the VM","text":"<p>Now, let's try a couple actions via the bindings to the VM's HTTP server. This server allows management of the VM, here are just a few possibilities, with a basic example of using the error handling response mechanisms the SDK provides.</p> <p>Get the VM's information:</p> <pre><code>// Get the VM's info\nvar vmInfoResponse = await vm.Management.GetInfoAsync();\nvmInfoResponse\n    .IfSuccess(vmInfo =&gt;\n    {\n        Console.WriteLine($\"The VM is called {vmInfo.Id}\");\n        Console.WriteLine($\"The VMM version is {vmInfo.VmmVersion}\");\n    })\n    .IfError(error =&gt;\n    {\n        Console.WriteLine($\"Received an error when trying to get info: {error}\");\n    });\n</code></pre> <p>Pause and resume the VM, plus a demonstration of response chaining:</p> <pre><code>// Pause and resume VM\nvar pauseResponse = await vm.Management.UpdateStateAsync(new VmStateUpdate(VmStateForUpdate.Paused));\nvar resumeResponse = await vm.Management.UpdateStateAsync(new VmStateUpdate(VmStateForUpdate.Resumed));\npauseResponse\n    .ChainWith(resumeResponse)\n    .IfSuccess(() =&gt; Console.WriteLine(\"Paused and resumed VM!\"))\n    .IfError(error =&gt; Console.WriteLine($\"Got an error when pausing and resuming: {error}\"));\n</code></pre>"},{"location":"getting-started/3-creating-a-basic-app/#using-the-vms-tty","title":"Using the VM's TTY","text":"<p>The SDK's TTY system is highly advanced and is a huge topic of its own, with output buffering, completion tracking and multiplexing capabilities. Here, just for demonstration, we'll simply run a <code>cat --help</code> command, await it and print out its output: <pre><code>// Run a command in the VM's TTY\nvar output = await vm.TtyClient.RunBufferedCommandAsync(\"cat --help\");\nConsole.WriteLine(\"Received from command:\");\nConsole.WriteLine(output);\n</code></pre></p>"},{"location":"getting-started/3-creating-a-basic-app/#shutting-down-the-vm","title":"Shutting down the VM","text":"<p>It's as simple as:</p> <pre><code>// Shut down the VM\nvar shutdownResult = await vm.ShutdownAsync();\nif (shutdownResult.IsFailure() || shutdownResult.IsSoftFailure())\n{\n    Console.WriteLine(\"Couldn't shut down VM!\");\n}\n</code></pre>"}]}